# -*- coding: utf-8 -*-
"""Ch3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lzi2skpBPeuRLzYpAjClbZQU8H6vQs44
"""

import matplotlib.pyplot as plt
import numpy as np
def sigmoid(f):
    return 1/(1 + np.exp(-f))
f = np.linspace(-10, 10, 50)
print(f)

g = np.round(sigmoid(f), 3)
g

plt.plot(f, g)
plt.xlabel("f")
plt.ylabel("g (sigmoid)")

g = np.tanh(f)
print(g)
plt.plot(f, g)
plt.xlabel("f")
plt.ylabel("g (tanh)")

def relu(f):
    return np.maximum(f, 0) 

g = relu(f)
plt.plot(f, g)
plt.xlabel("f")
plt.ylabel("g (relu)")

import tensorflow as tf
print(tf.__version__)

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt

mnist = tf.keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()

print(type(x_train))
print(type(y_train))
print(type(x_test))
print(type(x_test))

"""# Plot image"""

plt.imshow(x_train[0], cmap='gray')
print("Actual value of the digit: {0}".format(y_train[0]))

print(x_train.shape)
print(y_train.shape)
print(x_test.shape)
print(y_test.shape)

tf.keras.utils.array_to_img(x_train[0].reshape(28,28,1))

"""# Image Pre-processing
## Flatten using `reshape()` function
"""

x_train = x_train.reshape(x_train.shape[0], x_train.shape[1] * x_train.shape[2])
x_test = x_test.reshape(x_test.shape[0], x_test.shape[1] * x_test.shape[2])
print(x_train.shape)
print(x_test.shape)

"""## Min-Max Normalization"""

x_train=x_train / 255.0
x_test=x_test/255.0

"""# Building the Model
## Sequential API
Parameter `input_shape` is used in the first laye.
"""

model = tf.keras.models.Sequential()
model.add(tf.keras.layers.Dense(128, input_shape=((784, )), activation='relu'))
model.add(tf.keras.layers.Dense(128, activation='relu'))
model.add(tf.keras.layers.Dense(10))

model.summary()

tf.keras.utils.plot_model(model, to_file='model.png', dpi=120, show_shapes=True)

"""Explicitly `InputLayer` is used."""

model = tf.keras.models.Sequential()
model.add(tf.keras.layers.InputLayer((784,)))
model.add(tf.keras.layers.Dense(128, activation='relu'))
model.add( tf.keras.layers.Dense(128, activation='relu'))
model.add(tf.keras.layers.Dense(10))

"""The `Flatten` layer is used to flatten the input image. 

**NOTE:** If the `Flatten` layer is used in model, we must not flatten the input during image pre-processing step using the `reshape()` function.
"""

model = tf.keras.models.Sequential([
  tf.keras.layers.Flatten(input_shape=(28, 28)),
  tf.keras.layers.Dense(128, activation='relu'),
  tf.keras.layers.Dense(128, activation='relu'),
  tf.keras.layers.Dense(10, activation='softmax')
])

model.summary()

model.summary()

tf.keras.utils.plot_model(model, to_file='model.png', dpi=120, show_shapes=True)

"""## Functional API"""

inputs = tf.keras.Input((784,)) 
hidden_1 = tf.keras.layers.Dense(128, activation='relu')(inputs)
hidden_2 = tf.keras.layers.Dense(128, activation='relu')(hidden_1)
outputs = tf.keras.layers.Dense(10)(hidden_2)
model = tf.keras.Model(inputs=inputs, outputs=outputs)

model.summary()

"""## Model Subclassing"""

class MyModel(tf.keras.Model):
    def __init__(self, input_shape, target_classes):
        # call the parent constructor
        super(MyModel, self).__init__()
      
        # layer set
        self.inputs = tf.keras.layers.InputLayer(input_shape)
        self.hidden_1 = tf.keras.layers.Dense(128, activation='relu')
        self.hidden_2 = tf.keras.layers.Dense(128, activation='relu')
        self.outputs = tf.keras.layers.Dense(target_classes)

    def call(self, x):
        x = self.inputs(x)
        x = self.hidden_1(x)
        x = self.hidden_2(x)
        x = self.outputs(x)
        return x

model = MyModel((784,),10)

"""# Compiling the Model"""

model.compile(
    optimizer=tf.keras.optimizers.Adam(0.001),
    loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
    metrics=[tf.keras.metrics.SparseCategoricalAccuracy()],
)

"""# Training the Model"""

history = model.fit(x_train, y_train, epochs=50, batch_size=32, steps_per_epoch=200,
                    verbose=2,validation_steps=50,validation_split=0.2)

"""# Evaluating the Model"""

model.evaluate(x_test, y_test)

y_pred = model.predict(x_test)

print(y_test[0])
print(y_pred[0])

"""# Plot loss and accuracy"""

# plot accuracy
plt.plot(history.history['sparse_categorical_accuracy'])
plt.plot(history.history['val_sparse_categorical_accuracy'])
plt.title('model accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()
# plot loss
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

"""# TensorBoard"""

# Commented out IPython magic to ensure Python compatibility.
# %load_ext tensorboard

!rm -rf ./logs/

tensorboard_callback = tf.keras.callbacks.TensorBoard('./logs/', histogram_freq=1)

history = model.fit(x_train, y_train, epochs=50, batch_size=32, steps_per_epoch=200,
                    verbose=1,validation_steps=50,validation_split=0.2, 
                    callbacks=[tensorboard_callback])

# Commented out IPython magic to ensure Python compatibility.
# %tensorboard --logdir logs

!pip install -q -U keras-tuner

import keras_tuner as kt

def build_model(hp):
    model = tf.keras.models.Sequential()
    model.add(tf.keras.layers.InputLayer((784,)))

    hp_layers = hp.Int('layers', min_value=2, max_value=4, step=1)
    hp_units = hp.Int('units', min_value=128, max_value=512, step=128)
    hp_activations = hp.Choice('activation', ['relu', 'tanh'])

    for i in range(hp_layers):
        model.add(tf.keras.layers.Dense(units=hp_units, activation=hp_activations)) 

    model.add(tf.keras.layers.Dense(10))

    hp_learning_rate = hp.Choice('learning_rate', values=[0.01,0.001, 0.0001])

    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=hp_learning_rate),
                  loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
                  metrics=['accuracy'])

    return model

tuner = kt.Hyperband(build_model,
                     objective='val_accuracy',
                     max_epochs=10,
                     directory='proj_dir',
                     project_name='mnist')

tuner.search(x_train, y_train, epochs=50, batch_size=32, steps_per_epoch=200,
             validation_split=0.2)

best_hps = tuner.get_best_hyperparameters(num_trials=1)[0]

print(best_hps.get("layers"))
print(best_hps.get("units"))
print(best_hps.get("activation"))
print(best_hps.get("learning_rate"))

"""# Save and Load model"""

!rm -r checkpoints

chkpoint_callback = tf.keras.callbacks.ModelCheckpoint(
    filepath="./checkpoints/model_chkpoint", 
    save_best_only=True,
    save_weights_only=False)

history = model.fit(x_train, y_train, epochs=50, batch_size=32, 
                    steps_per_epoch=200, verbose=2,validation_steps=50,
                    validation_split=0.2, callbacks=[chkpoint_callback],)

# Loading weights from chekpoints when save_weights_only = True
# NOTE: We must define the model architecture and compile it before loading weights

model.load_weights("./checkpoints/model_chkpoint")

# Loading the entire model from chekpoints when save_weights_only = False
# No need to define the model architecture and compile before loading

new_model = tf.keras.models.load_model("./checkpoints/model_chkpoint")

# Use the loaded models to evaluate test data
model.evaluate(x_test, y_test)

new_model.evaluate(x_test, y_test)

model.save("mnist_model")

import numpy as np
a = np.array([[0,0,0,0,0,0,0],[0,255,255,255,255,255,0],[0,255,0,255,0,255,0],[0,255,0,0,0,255,0],[0,255,255,255,0,255,0],[0,255,255,255,255,255,0],[0,0,0,0,0,0,0]])
b = np.array([[1,0,-1],[1,0,-1],[1,0,-1]])
#np.sum(np.multiply(a,b).flatten())

a

b

def c2d(image, kernel):
    m, n = kernel.shape
    if (m == n):
        y, x = image.shape
        y = y - m + 1
        x = x - m + 1
        new_image = np.zeros((y,x))
        for i in range(y):
            for j in range(x):
                new_image[i][j] = np.sum(image[i:i+m, j:j+m]*kernel)
    return new_image

c2d(a, b)

